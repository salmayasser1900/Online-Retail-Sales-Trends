# -*- coding: utf-8 -*-
"""Python part.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18eo63WsooFO-v7XWIZcUnE0oShSoPIUi
"""

import pandas as pd
import os
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

dataset = pd.read_csv('/content/drive/MyDrive/FinalProject/sales_data_sample.csv', encoding= 'unicode_escape')
dataset.head()

# Check for missing values
missing_values = dataset.isnull().sum()
print("Missing values before handling:")
print(missing_values[missing_values > 0])

# Handle missing values
dataset['ADDRESSLINE2'].fillna('N/A', inplace=True)
dataset['STATE'].fillna('Unknown', inplace=True)
dataset['POSTALCODE'].fillna('00000', inplace=True)
dataset['TERRITORY'].fillna('Not Specified', inplace=True)
dataset.head()

# Verify that missing values are handled
missing_values_after = dataset.isnull().sum()
print("\nMissing values after handling:")
print(missing_values_after[missing_values_after > 0])
dataset.head()

print("First few rows of the dataset:")
print(dataset.head())

# Plot missing values before handling
plt.figure(figsize=(10, 6))
sns.barplot(x=missing_values.index, y=missing_values.values)
plt.xticks(rotation=90)
plt.title('Missing Values Before Handling')
plt.show()

# Verify that missing values are handled
missing_values_after = dataset.isnull().sum()

# Plot missing values after handling
plt.figure(figsize=(10, 6))
sns.barplot(x=missing_values_after.index, y=missing_values_after.values)
plt.xticks(rotation=90)
plt.title('Missing Values After Handling')
plt.show()

# Convert ORDERDATE to datetime format
dataset['ORDERDATE'] = pd.to_datetime(dataset['ORDERDATE'])

# Extract relevant date parts for analysis
dataset['YEAR'] = dataset['ORDERDATE'].dt.year
dataset['MONTH'] = dataset['ORDERDATE'].dt.month
dataset['DAY'] = dataset['ORDERDATE'].dt.day
dataset['DAY_OF_WEEK'] = dataset['ORDERDATE'].dt.dayofweek

# Verify the changes
dataset[['ORDERDATE', 'YEAR', 'MONTH', 'DAY', 'DAY_OF_WEEK']].head()

# Group by customer and calculate total spending and purchase frequency
customer_data = dataset.groupby('CUSTOMERNAME').agg({
    'SALES': 'sum',
    'ORDERNUMBER': 'count'
}).rename(columns={'SALES': 'TOTAL_SPENDING', 'ORDERNUMBER': 'PURCHASE_FREQUENCY'})

# Define segments based on spending and frequency
customer_data['SEGMENT'] = pd.qcut(customer_data['TOTAL_SPENDING'], 4, labels=['Low', 'Medium', 'High', 'V. High'])

# Visualize customer segments
plt.figure(figsize=(10, 6))
sns.countplot(x='SEGMENT', data=customer_data)
plt.title('Customer Segments Based on Total Spending')
plt.show()

# Group by year and month to analyze sales trends
monthly_sales = dataset.groupby(['YEAR', 'MONTH']).agg({'SALES': 'sum'}).reset_index()

# Plot monthly sales trends
plt.figure(figsize=(14, 7))
sns.lineplot(x='MONTH', y='SALES', hue='YEAR', data=monthly_sales, marker='o')
plt.title('Monthly Sales Trends Over Years')
plt.show()

# Group by day of week to analyze weekly sales trends
weekly_sales = dataset.groupby('DAY_OF_WEEK').agg({'SALES': 'sum'}).reset_index()

# Plot weekly sales trends
plt.figure(figsize=(10, 6))
sns.barplot(x='DAY_OF_WEEK', y='SALES', data=weekly_sales)
plt.title('Weekly Sales Trends')
plt.show()

# Assuming a simple CLTV calculation based on total spending
customer_data['CLTV'] = customer_data['TOTAL_SPENDING'] * customer_data['PURCHASE_FREQUENCY']

# Visualize CLTV distribution
plt.figure(figsize=(10, 6))
sns.histplot(customer_data['CLTV'], bins=30)
plt.title('Customer Lifetime Value Distribution')
plt.show()









